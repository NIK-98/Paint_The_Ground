## ~/CodeNameTwister $
extends RefCounted

const SEPARATOR : String = "\n===============================================================================\n"
const SUBSEPARATOR : String = "\n-------------------------------------------------------------------------------\n"
const TAB : String = "\t"
const EOL : String = "[generated by license me]"

#region disclaimer
func get_disclaimer_others() -> String:
	return """
# ------------------------------------
# Disclaimer for base licenses:
# ------------------------------------
# It can be external software or portion of code integrated into the main project that contains a separate license.
"""

func get_disclaimer_thirdparty() -> String:
	return """
# ------------------------------------
# Disclaimer for thirdparty licenses:
# ------------------------------------
# It can be external software, portion of code, plugin or addons integrated into the main project that contains a separate license.
"""

func get_disclaimer_inbuilt_thirdparty() -> String:
	return """
# ------------------------------------
# Disclaimer for thirdparty libraries:
# ------------------------------------
#
# Licensing details for thirdparty libraries in the 'thirdparty/' directory
# are given in summarized form, i.e. with only the "main" license described
# in the library's license statement. Different licenses of single files or
# code snippets in thirdparty libraries are not documented here.
# For example:
#   Name: Zlib
#   Files: ./thirdparty/zlib/
#   Copyright: 1995-2017, Jean-loup Gailly and Mark Adler
#   License: Zlib
# The exact copyright for each file in that library *may* differ, and some
# files or code snippets might be distributed under other compatible licenses
# (e.g. a public domain dedication), but as far as Godot Engine is concerned
# the library is considered as a whole under the Zlib license.
"""
#endregion

var update_date_license : bool = true

func get_licensor_data() -> Dictionary:
	var today : Dictionary = {}
	if !update_date_license and FileAccess.file_exists("user://published.info"):
		var cfg : ConfigFile = ConfigFile.new()
		cfg.load("user://published.info")
		today = cfg.get_value("PUBLISHED","DATE", Time.get_datetime_dict_from_system())
	else:
		if update_date_license:
			if FileAccess.file_exists("user://published.info"):
				DirAccess.remove_absolute("user://published.info")
		today = Time.get_datetime_dict_from_system()
	return {
		"PROJECT" : ProjectSettings.get_setting("application/license/project_name",ProjectSettings.get_setting("application/config/name"))
		,"AUTHOR" : ProjectSettings.get_setting("application/license/author", "Licensor")
		,"YEAR" : ProjectSettings.get_setting("application/license/year", Time.get_datetime_dict_from_system()["year"])
		,"TYPE" : ProjectSettings.get_setting("application/license/type", "Copyright")
		,"TODAY" : "{0}-{1}-{2}".format([today["year"],today["month"],today["day"]])
		,"CUSTOMER" : "Customer"
		}

func _is_file_valid(file : String, start : PackedStringArray, ext : PackedStringArray) -> bool:
	for b : String in start:
		if file.begins_with(b):
			var file_ext : String = file.get_extension()
			for e : String in ext:
				if file_ext == e:
					return true
	return false

func _get_files(path : String, start : PackedStringArray, ext : PackedStringArray) -> PackedStringArray:
	var files : PackedStringArray
	var dirs : Array[String] = [path]
	while dirs:
		var dir : String = dirs.pop_front()
		for sub_dir in DirAccess.get_directories_at(dir):
			if !sub_dir.begins_with("."):
				dirs.append(dir.path_join(sub_dir))
		for file in DirAccess.get_files_at(dir):
			if _is_file_valid(file.to_lower(), start, ext):
				files.append(dir.path_join(file))
	return files

func _get_license_data_file(type : String) -> String:
	var out : String = ""
	var sc : Script = get_script()
	var file : String = "res://addons/license_me/licenses/"
	if sc:
		file = sc.resource_path.get_base_dir().path_join("licenses")
	file = file.path_join(type.to_lower()) + ".uc"
	if FileAccess.file_exists(file):
		out = FileAccess.get_file_as_string(file)
	else:
		push_error("Can't open license file: ", type, " not found!")
	return out

func get_licenses_as_dictionary(licensor_data : Dictionary, files : PackedStringArray = []) -> Dictionary:
	var data_dict : Dictionary = {}#"PROJECT":{},"MAIN_LICENSES":{},"THIRDPARTY_LICENSES":{},"BASE_LICENSES":{}

	var main_project : String = licensor_data["PROJECT"]
	var author_project : String = licensor_data["AUTHOR"]

	if author_project == "":
		author_project = ProjectSettings.get_setting("application/license/author", "DevGames Studio")#ProjectSettings.get_setting("application/config/name", "DevGames Studio")
		#TOOD

	var type : String = str(licensor_data["TYPE"]).to_upper().strip_edges()
	if type == "COPYRIGHT":
		author_project = "Copyright (c) {0} {1}, {2}. All rights reserved.".format([licensor_data["YEAR"], author_project, main_project])
		var sc : Script = get_script()
		var file : String = "res://addons/license_me/licenses/"
		if sc:
			file = sc.resource_path.get_base_dir().path_join("licenses")
		file = file.path_join(type.to_lower()) + ".uc"
		if FileAccess.file_exists(file):
			var data : Dictionary = read(file)
			if data.size() > 0:
				var _header : String = "{0}\n{1}".format(["SOFTWARE_LICENSE_AGGREEMENT", str(data["SOFTWARE_LICENSE_AGGREEMENT"]).strip_edges()])
				var definitions : String = ""
				var full_body : String = ""

				var definitions_data : Dictionary = data["DEFINITIONS"]

				for z in ["DEFINITIONS","GOVERNINGf_LAW","SOFTWARE_LICENSE_AGGREEMENT", "TERMINATION", "DEFINITIONS", "WARRANTY_AND_LIABILITY", "DISTRIBUTION_RIGHTS"]:
					if licensor_data.has(z):
						licensor_data.erase(z)
				for l in licensor_data.keys():
					if data.has(l):
						full_body += "\n\n{0}\n{1}".format([str(l).capitalize().to_upper(), str(data[l]).strip_edges()])

				full_body = str(_header.strip_edges(),'\n', "[_DEFINITIONS_]", full_body)

				for x : String in ["DISTRIBUTION_RIGHTS","WARRANTY_AND_LIABILITY","TERMINATION"]:
					if data.has(x):
						full_body = str(full_body, "\n\n{0}\n{1}".format([x.capitalize().to_upper(), str(data[x]).strip_edges()]))

				if licensor_data.has("COUNTRY"):
					var country : String = str(licensor_data["COUNTRY"])
					if country.length() > 0 and data["GOVERNING_LAW"]:
						full_body = str(full_body, "\n\n{0}\n{1}".format(["GOVERING LAW", str(data["GOVERNING_LAW"]).strip_edges()]))

				for x in licensor_data.keys():
					full_body = full_body.replace("{{0}}".format([x]), str(licensor_data[x]))

				for f in definitions_data.keys():
					var key : String = str(f).strip_edges()
					if full_body.containsn(key):
						definitions += str("\n\n- ", key.capitalize(), ": " , str(definitions_data[f]).strip_edges())
				if definitions.length() > 0:
					full_body = full_body.replace("[_DEFINITIONS_]", "\n{0}\n{1}".format(["DEFINITIONS",definitions.strip_edges()]))
				else:
					full_body = full_body.replace("[_DEFINITIONS_]", "")

				author_project = str(SEPARATOR, TAB,author_project, SEPARATOR, full_body)
				if licensor_data.has("EXTRA_CLAUSULE"):
					var extra : String = str(licensor_data["EXTRA_CLAUSULE"]).strip_edges()
					if extra.length() > 0:
						author_project = str(author_project,"\n\n", extra)
			else:
				push_error("Error on trying read copyrights clausules")
	elif type != "IGNORE":
		var is_unlicensed : bool = type == "UNLICENSE"
		if is_unlicensed:
			author_project = "Copyright (c) {0} {1}. {2} is unlicensed.".format([licensor_data["YEAR"], author_project, main_project, type.to_upper()])
		else:
			author_project = "Copyright (c) {0} {1}. {2} is under {3} license.".format([licensor_data["YEAR"], author_project, main_project, type.to_upper()])
		var license : String = _get_license_data_file(type)
		if license.length() > 0:
			for x in licensor_data.keys():
				license = license.replace("{{0}}".format([x]), str(licensor_data[x]))
			if is_unlicensed:
				author_project = str(SEPARATOR, TAB,author_project, SEPARATOR, license)
			else:
				author_project = str(SEPARATOR, TAB,author_project, SEPARATOR, "\t\t\t", type ," LICENSE\t\t\t", license)

	if author_project.length() > 0:

		data_dict[str(main_project.to_upper()) + "_PROJECT/COPYRIGHT_NOTICE_LICENSE"] = author_project.strip_edges()

	var base_disclaimer : bool = false
	var third_disclaimer : bool = false
	for f : String in files:
		if !FileAccess.file_exists(f):continue
		var data : String = FileAccess.get_file_as_string(f)
		if data.ends_with(EOL):continue
		var base_dir : String = f.get_base_dir()
		var file_name : String = f.get_file()
		file_name = file_name.trim_suffix("." + file_name.get_extension())
		if base_dir == "res://":
			base_dir = base_dir.get_slice("/", base_dir.get_slice_count("/") - 1)
			var token : String = "PROJECT_LICENSES".path_join(file_name)
			var indx : int = 0
			while data_dict.has(token):
				token = "MAIN_LICENSES".path_join(base_dir.trim_prefix("res://")).path_join(file_name) + "_" + str(indx)
				indx+=1
			data_dict[token] = data.strip_edges()
		elif base_dir.begins_with("res://addons/"):
			base_dir = base_dir.get_slice("/", base_dir.get_slice_count("/") - 1)
			var token : String = "THIRDPARTY_LICENSES".path_join(base_dir.trim_prefix("res://")).path_join(file_name)
			var indx : int = 0
			while data_dict.has(token):
				token = "THIRDPARTY_LICENSES".path_join(base_dir.trim_prefix("res://")).path_join(file_name) + "_" + str(indx)
				indx+=1
			data_dict[token] = data.strip_edges()
			third_disclaimer =  true
		else:
			base_dir = base_dir.get_slice("/", base_dir.get_slice_count("/") - 1)
			var token : String = "BASE_LICENSES".path_join(base_dir.trim_prefix("res://")).path_join(file_name)
			var indx : int = 0
			while data_dict.has(token):
				token = "BASE_LICENSES".path_join(base_dir.trim_prefix("res://")).path_join(file_name) + "_" + str(indx)
				indx+=1
			data_dict[token] = data.strip_edges()
			base_disclaimer =  true

	if base_disclaimer:
		data_dict["BASE_LICENSES/DISCLAIMER"] = get_disclaimer_others().strip_edges()
	if third_disclaimer:
		data_dict["THIRDPARTY_LICENSES/DISCLAIMER"] = get_disclaimer_thirdparty().strip_edges()
	return data_dict

func get_licenses(licensor_data : Dictionary, files : PackedStringArray) -> String:
	var main_project : String = licensor_data["PROJECT"]
	var author_project : String = licensor_data["AUTHOR"]

	var header : String = ""
	var others : String = ""
	var thirdparty : String = ""

	if author_project == "":
		author_project = ProjectSettings.get_setting("application/license/author", "DevGames Studio")
		#TOOD

	var type : String = str(licensor_data["TYPE"]).to_upper().strip_edges()
	if type == "COPYRIGHT":
		author_project = "Copyright (c) {0} {1}, {2}. All rights reserved.".format([licensor_data["YEAR"], author_project, main_project])
		var sc : Script = get_script()
		var file : String = "res://addons/license_me/licenses/"
		if sc:
			file = sc.resource_path.get_base_dir().path_join("licenses")
		file = file.path_join(type.to_lower()) + ".uc"
		if FileAccess.file_exists(file):
			var data : Dictionary = read(file)
			if data.size() > 0:
				var _header : String = "{0}\n{1}".format(["SOFTWARE_LICENSE_AGGREEMENT", str(data["SOFTWARE_LICENSE_AGGREEMENT"]).strip_edges()])
				var definitions : String = ""
				var full_body : String = ""

				var definitions_data : Dictionary = data["DEFINITIONS"]

				for z in ["DEFINITIONS","GOVERNINGf_LAW","SOFTWARE_LICENSE_AGGREEMENT", "TERMINATION", "DEFINITIONS", "WARRANTY_AND_LIABILITY", "DISTRIBUTION_RIGHTS"]:
					if licensor_data.has(z):
						licensor_data.erase(z)
				for l in licensor_data.keys():
					if data.has(l):
						full_body += "\n\n{0}\n{1}".format([str(l).capitalize().to_upper(), str(data[l]).strip_edges()])

				full_body = str(_header.strip_edges(),'\n', "[_DEFINITIONS_]", full_body)

				for x : String in ["DISTRIBUTION_RIGHTS","WARRANTY_AND_LIABILITY","TERMINATION"]:
					if data.has(x):
						full_body = str(full_body, "\n\n{0}\n{1}".format([x.capitalize().to_upper(), str(data[x]).strip_edges()]))

				if licensor_data.has("COUNTRY"):
					var country : String = str(licensor_data["COUNTRY"])
					if country.length() > 0 and data["GOVERNING_LAW"]:
						full_body = str(full_body, "\n\n{0}\n{1}".format(["GOVERING LAW", str(data["GOVERNING_LAW"]).strip_edges()]))

				for x in licensor_data.keys():
					full_body = full_body.replace("{{0}}".format([x]), str(licensor_data[x]))

				for f in definitions_data.keys():
					var key : String = str(f).strip_edges()
					if full_body.containsn(key):
						definitions += str("\n\n- ", key.capitalize(), ": " , str(definitions_data[f]).strip_edges())
				if definitions.length() > 0:
					full_body = full_body.replace("[_DEFINITIONS_]", "\n{0}\n{1}".format(["DEFINITIONS",definitions.strip_edges()]))
				else:
					full_body = full_body.replace("[_DEFINITIONS_]", "")

				author_project = str(SEPARATOR, TAB,author_project, SEPARATOR, full_body)
				if licensor_data.has("EXTRA_CLAUSULE"):
					var extra : String = str(licensor_data["EXTRA_CLAUSULE"]).strip_edges()
					if extra.length() > 0:
						author_project = str(author_project,"\n\n", extra)
			else:
				push_error("Error on trying read copyrights clausules")
	elif type != "IGNORE":
		var is_unlicensed : bool = type == "UNLICENSE"
		if is_unlicensed:
			author_project = "Copyright (c) {0} {1}. {2} is unlicensed.".format([licensor_data["YEAR"], author_project, main_project, type.to_upper()])
		else:
			author_project = "Copyright (c) {0} {1}. {2} is under {3} license.".format([licensor_data["YEAR"], author_project, main_project, type.to_upper()])
		var license : String = _get_license_data_file(type)
		if license.length() > 0:
			for x in licensor_data.keys():
				license = license.replace("{{0}}".format([x]), str(licensor_data[x]))
			if is_unlicensed:
				author_project = str(SEPARATOR, TAB,author_project, SEPARATOR, license)
			else:
				author_project = str(SEPARATOR, TAB,author_project, SEPARATOR, "\t\t\t", type ," LICENSE\t\t\t", license)

	for f : String in files:
		if !FileAccess.file_exists(f):continue
		var data : String = FileAccess.get_file_as_string(f)
		if data.ends_with(EOL):continue
		var base_dir : String = f.get_base_dir()
		var file : String = f.get_file()
		data = data.strip_edges()
		file = (file.trim_suffix("." + file.get_extension())).to_upper()
		var last : String = ""
		#if file == "LICENSE":
			#file = ""
		if base_dir == "res://":
			file = str(main_project,"/").path_join(file).to_lower()
			header += str(SUBSEPARATOR, "Base: ", file, "\n\n", data,"\n")
		elif base_dir.begins_with("res://addons"):
			var dir : String = base_dir.get_slice("/", base_dir.get_slice_count("/") - 1)
			if last != dir:
				last = dir
				var head : String = "License for {0}".format([dir.capitalize()])
				file = dir.path_join(file).to_lower()
				thirdparty += str(SUBSEPARATOR, TAB, head,SUBSEPARATOR, "Base: ", file,"\n\n", data,'\n')
			else:
				thirdparty += str(SUBSEPARATOR, "Base: ", file,"\n\n", data,'\n')
		else:
			var dir : String = base_dir.get_slice("/", base_dir.get_slice_count("/") - 1)
			if last != dir:
				last = dir
				var head : String = "License for {0}".format([dir.capitalize()])
				file = dir.path_join(file).to_lower()
				others += str(SUBSEPARATOR, TAB, head,SUBSEPARATOR, "Base: ", file,"\n\n", data,'\n')
			else:
				others += str(SUBSEPARATOR, "Base: ", file,"\n\n", data,'\n')
	if header.length() > 0:
		header = str(SEPARATOR, TAB, main_project.capitalize().to_upper() ," LICENSE", SEPARATOR, header.trim_prefix(SUBSEPARATOR))
	if others.length() > 0:
		others = str(SEPARATOR, TAB,"BASE SOURCE LICENSES",SEPARATOR, get_disclaimer_others(), others)
	if thirdparty.length() > 0:
		thirdparty = str(SEPARATOR, TAB, "THIRD PARTY LICENSES", SEPARATOR, get_disclaimer_thirdparty(), thirdparty)
	return str(author_project,'\n',header,'\n', others,'\n', thirdparty).strip_edges()

func get_export() -> Exp:
	if _exp == null:
		_exp = Exp.new()
		_exp.get_licenses = run
		_exp.base_path = (get_script() as Script).resource_path.get_base_dir().path_join("/")
	return _exp

#func _get_licenses_callback() -> String:
	#var prefix : PackedStringArray = ["license", "eula"]
	#var extensions : PackedStringArray = ["license", "md", "txt", "uc", "", "eula"]
	#return get_licenses(get_licensor_data(), _get_files("res://", prefix, extensions))

var _exp : Exp = null


func get_built_in_licenses_as_dict() -> Dictionary:
	var data_out : Dictionary = {}
	data_out["DISCLAIMER"] = get_disclaimer_inbuilt_thirdparty().strip_edges()
	var copyrights : Array[Dictionary] = Engine.get_copyright_info()
	for c : Dictionary in copyrights:
		data_out[c["name"]] = c
	return data_out

func get_built_in_licenses() -> String:
	var out : String = ""
	var copyrights : Array[Dictionary] = Engine.get_copyright_info()

	out += str(SEPARATOR, TAB, "THIRD PARTY LIBRARIES", SEPARATOR)
	out += get_disclaimer_inbuilt_thirdparty()

	var type_licenses : Dictionary = {}
	var subout : String = ""
	for c : Dictionary in copyrights:
		out += str("\n",SUBSEPARATOR, TAB, (c["name"] as String).to_upper(), SUBSEPARATOR)
		out += str("Name: ", c["name"])
		subout = ""
		for p in c["parts"]:
			subout += '\n'
			if p.has("files"):
				var files : String = ""
				for f in p["files"]:
					files += "\n" + f
				if files.length() > 0:
					subout += str("\nFiles: ", files.strip_edges() ,"\n")
			if p.has("comments"):
				subout += str("\nComments: ", p["comments"] ,"\n")
			if p.has("copyright"):
				var cp : String = ""
				for cc in p["copyright"]:
					cp += str("\n", cc)
				if cp.length() > 0:
					cp = "Copyright: " + cp.strip_edges()
					subout += cp
			var license : String = p["license"]
			#if "Expat" in license:
				#license = license.replace("Expat", "MIT")
			if license.length() > 0:
				subout += str("\nLicense: ", license.strip_edges())
			else:
				subout += str("\nLicense: Unlicense")
		if subout.length() > 0:
			out += "\n" + subout.strip_edges() + "\n"
	return out


func run_as_dict(features : Dictionary = {}) -> Dictionary:
	var prefix : PackedStringArray = ["license", "eula"]
	var extensions : PackedStringArray = ["license", "md", "txt", "uc", "eula", ""]
	if features.has("PREFIX"):
		prefix = features["PREFIX"]
	if features.has("EXTENSIONS"):
		extensions = features["EXT"]
	var data_out : Dictionary = {}
	features.merge(get_licensor_data())
	if not features.has("BUILD_ALL") or true == features["BUILD_ALL"]:
		data_out["LICENSES"] = get_licenses_as_dictionary(features, _get_files("res://", prefix, extensions))
	else:
		data_out["LICENSES"] = get_licenses_as_dictionary(features,[])
	if not features.has("GODOT_LICENSES") or true == features["GODOT_LICENSES"]:
		data_out["IN_BUILT_LICENSES"] = get_built_in_licenses_as_dict()
		data_out["IN_BUILT_LICENSES_INFO"] = Engine.get_license_info()
	return data_out

func run(features : Dictionary = {}) -> String:
	var prefix : PackedStringArray = ["license", "eula"]
	var extensions : PackedStringArray = ["license", "md", "txt", "uc", "eula", ""]

	if features.has("PREFIX"):
		prefix = features["PREFIX"]
	if features.has("EXTENSIONS"):
		extensions = features["EXT"]
	var out : String = ""
	features.merge(get_licensor_data())
	if not features.has("BUILD_ALL") or true == features["BUILD_ALL"]:
		out = get_licenses(features, _get_files("res://", prefix, extensions))
	else:
		out = get_licenses(features,[])
	if not features.has("GODOT_LICENSES") or true == features["GODOT_LICENSES"]:
		out += "\n" + get_built_in_licenses()
		out += str(SEPARATOR,TAB,"USED LICENSES",SEPARATOR)
		out += "\n# This section will include details of engine and third-party library licenses mentioned above.\n"
		out += str(SUBSEPARATOR, TAB, "ENGINE LICENSES", SUBSEPARATOR, Engine.get_license_text())
		var info : Dictionary = Engine.get_license_info()
		for k in info.keys():
			out += str("\n",SUBSEPARATOR, TAB, str(k).to_upper(), SUBSEPARATOR, "License: ", str(k),"\n\n", info[k])
	return out.strip_edges() + "\n\n" + SEPARATOR+ TAB + EOL


	#if features.has("OF"):
		#_exp.enabled = true


class Exp extends EditorExportPlugin:
	var enabled : bool = true
	var base_path : String = "res://addons/license_me/"
	var export_path : String = ""
	var settings : Object = null

	var get_licenses : Callable

	func _get_name() -> String:
		return "license_me"

	func _export_begin(features: PackedStringArray, is_debug: bool, path: String, flags: int) -> void:
		if !is_debug:
			if !FileAccess.file_exists("user://published.info"):
				var cfg : ConfigFile = ConfigFile.new()
				cfg.set_value("PUBLISHED", "DATE", Time.get_datetime_dict_from_system())
				cfg.save("user://published.info")
		export_path = ProjectSettings.globalize_path(path).get_base_dir()

	func _export_file(path: String, type: String, features: PackedStringArray) -> void:
		if path.begins_with(base_path.path_join("licenses/")):skip()

	func _export_end() -> void:
		if !get_licenses.is_valid():return
		var use_extension : String = "txt"
		var file_name : String = "LICENSE"
		var data_settings : Dictionary = {}
		if settings:
			if settings.has_method(&"get_data_settings"):
				data_settings = settings.call(&"get_data_settings")
				if data_settings.has("FILE_EXTENSION"):
					use_extension = data_settings["FILE_EXTENSION"]
				if data_settings.has("FILE_NAME"):
					file_name = data_settings["FILE_NAME"]
		if use_extension.length() > 0:
			use_extension = str(".", use_extension.lstrip("."))
		var path_file : String = ProjectSettings.globalize_path(export_path.path_join("{0}{1}".format([file_name,use_extension])))
		var data : String = get_licenses.call(settings.get_data_settings())
		if data.length() > 0:
			if FileAccess.file_exists(path_file):
				DirAccess.remove_absolute(path_file)
			var file : FileAccess = FileAccess.open(path_file, FileAccess.WRITE)
			if null == file:
				push_error("Error: can't create license file!")
				return
			file.store_string(get_licenses.call(data_settings))
			add_file(export_path.path_join("_LICENSE_.uc"), data.to_utf8_buffer(), false)
		else:
			push_warning("Not found licenses!")

func read(path : String) -> Dictionary:
	var out : Dictionary = {}
	if FileAccess.file_exists(path):
		var data : String = FileAccess.get_file_as_string(path)
		var split : PackedStringArray = data.split('\n', true)
		var section : String = ""
		var definitions : bool = false
		var definitions_started : bool = false
		var definition_token : String = ""
		var empty : bool = false
		for s in split:
			if s.begins_with("#"):continue
			if s.is_empty():
				if empty:
					section = ''
				empty = true
			elif s.begins_with('['):
				section = s.strip_edges().trim_prefix('[').trim_suffix(']')
				if !out.has(section):
					if section == "DEFINITIONS":
						definitions = true
						out[section] = {}
					else:
						definitions = false
						out[section] = ""
				continue
			elif s.begins_with('-'):
				section = ''
			if !section.is_empty():
				empty = false
				if definitions:
					if !definitions_started and s.length() == 0:continue
					if s.contains(":"):
						definitions_started = true
						var sp : PackedStringArray = s.split(":", true, 1)
						if sp.size() > 1:
							definition_token = str(sp[0]).strip_edges()
							out[section][definition_token] = sp[1]
						#else:
							#out[section][sp[0]] = '' # UNDEFINED sp[0]
					else:
						if out[section].has(definition_token):
							out[section][definition_token] += '\n'+s
				else:
					out[section] += '\n' + s
	return out
